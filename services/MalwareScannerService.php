<?php
/**
 * Malware Scanner Service
 * Scans files for suspicious code patterns
 */
class MalwareScannerService
{
    private $signatures = [
        'eval_request' => [
            'pattern' => '/eval\s*\(\s*\$_(GET|POST|REQUEST|COOKIE|SERVER)/i',
            'severity' => 'critical',
            'description' => 'User input passed directly to eval()'
        ],
        'base64_eval' => [
            'pattern' => '/eval\s*\(\s*base64_decode\s*\(/i',
            'severity' => 'critical',
            'description' => 'Decoded base64 content passed to eval()'
        ],
        'shell_exec' => [
            'pattern' => '/(shell_exec|exec|system|passthru|proc_open|popen)\s*\(/i',
            'severity' => 'warning',
            'description' => 'Execution of system commands'
        ],
        'base64_long' => [
            'pattern' => '/base64_decode\s*\(\s*[\'"][a-zA-Z0-9+\/=]{100,}[\'"]\s*\)/i',
            'severity' => 'warning',
            'description' => 'Long base64 encoded string decoding'
        ],
        'GLOBALS_assignment' => [
            'pattern' => '/\$GLOBALS\s*\[\s*[\'"][a-z0-9_]+[\'"]\s*\]\s*=/i',
            'severity' => 'warning',
            'description' => 'Direct assignment to GLOBALS (often used by obfuscators)'
        ],
        'error_reporting_0' => [
            'pattern' => '/error_reporting\s*\(\s*0\s*\)/i',
            'severity' => 'info',
            'description' => 'Hiding all errors (common in malware)'
        ]
    ];

    private $exclude_dirs = ['.git', 'node_modules', 'vendor', 'cache', 'logs'];
    private $exclude_extensions = ['css', 'js', 'jpg', 'jpeg', 'png', 'gif', 'zip', 'pdf', 'svg', 'woff', 'woff2', 'eot', 'ttf'];

    private $wp_dir;

    public function __construct()
    {
        $config = Config::getInstance();
        $this->wp_dir = $config->get('wp_dir');
    }

    /**
     * Run the scan
     * @return array List of suspicious files
     */
    public function scan()
    {
        $results = [];
        $files = $this->getFiles($this->wp_dir);

        foreach ($files as $file) {
            $matches = $this->scanFile($file);
            if (!empty($matches)) {
                $results[] = [
                    'file' => str_replace($this->wp_dir, '', $file),
                    'full_path' => $file,
                    'matches' => $matches
                ];
            }
        }

        return $results;
    }

    /**
     * Recursively get files
     * @param string $dir
     * @return array
     */
    private function getFiles($dir)
    {
        $files = [];
        if (!is_dir($dir))
            return $files;

        $iter = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($dir, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::SELF_FIRST,
            RecursiveIteratorIterator::CATCH_GET_CHILD // Ignore permission errors
        );

        foreach ($iter as $path => $dir_obj) {
            if ($dir_obj->isDir()) {
                if (in_array($dir_obj->getFilename(), $this->exclude_dirs)) {
                    continue; // Skip this directory (iterator will still enter it unless we handle it differently, but for RII we can't easily skip children without custom FilterIterator. For MVP this scans excluded dirs too but we skip adding them. Actually SKIP_DOTS helps. 
                    // To properly skip recursing into .git etc with RII is harder without FilterIterator. 
                    // For now, let's just do a simple check on path to skip adding files in excluded dirs.
                }
            } else {
                // Check extension
                $ext = strtolower(pathinfo($path, PATHINFO_EXTENSION));
                if (in_array($ext, $this->exclude_extensions)) {
                    continue;
                }

                // Check if path contains excluded dir
                foreach ($this->exclude_dirs as $exclude) {
                    if (strpos($path, DIRECTORY_SEPARATOR . $exclude . DIRECTORY_SEPARATOR) !== false) {
                        continue 2;
                    }
                }

                $files[] = $path;
            }
        }
        return $files;
    }

    /**
     * Scan a single file content
     * @param string $path
     * @return array
     */
    private function scanFile($path)
    {
        $matches = [];
        $content = file_get_contents($path);

        if ($content === false)
            return [];

        // Skip scanning if file is too large (> 1MB) to prevent memory issues
        if (strlen($content) > 1024 * 1024) {
            return [];
        }

        foreach ($this->signatures as $key => $sig) {
            if (preg_match_all($sig['pattern'], $content, $m, PREG_OFFSET_CAPTURE)) {
                foreach ($m[0] as $match) {
                    $offset = $match[1];
                    $line = substr_count(substr($content, 0, $offset), "\n") + 1;
                    $matches[] = [
                        'signature' => $key,
                        'severity' => $sig['severity'],
                        'description' => $sig['description'],
                        'line' => $line,
                        'snippet' => substr($content, max(0, $offset - 20), 100)
                    ];
                }
            }
        }

        return $matches;
    }
}
